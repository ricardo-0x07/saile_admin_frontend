schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

# columns and relationships of "account"
type account @model{
  address: String!
  domain: String
  email: String!
  employees: Int!
  fax: String!
  id: Int!
  name: String
  phone: String!
  revenue: String!

  # An object relationship
  sailebot: sailebot!
  sailebot_id: Int!
  state: String

  # An array relationship
  targets(
    # distinct select on columns
    distinct_on: [target_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [target_order_by!]

    # filter the rows returned
    where: target_bool_exp
  ): [target!]!

  # An aggregated array relationship
  targets_aggregate(
    # distinct select on columns
    distinct_on: [target_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [target_order_by!]

    # filter the rows returned
    where: target_bool_exp
  ): target_aggregate!
  website: String!
}

# aggregated selection of "account"
type account_aggregate {
  aggregate: account_aggregate_fields
  nodes: [account!]!
}

# aggregate fields of "account"
type account_aggregate_fields {
  avg: account_avg_fields
  count(columns: [account_select_column!], distinct: Boolean): Int
  max: account_max_fields
  min: account_min_fields
  stddev: account_stddev_fields
  stddev_pop: account_stddev_pop_fields
  stddev_samp: account_stddev_samp_fields
  sum: account_sum_fields
  var_pop: account_var_pop_fields
  var_samp: account_var_samp_fields
  variance: account_variance_fields
}

# order by aggregate values of table "account"
input account_aggregate_order_by {
  avg: account_avg_order_by
  count: order_by
  max: account_max_order_by
  min: account_min_order_by
  stddev: account_stddev_order_by
  stddev_pop: account_stddev_pop_order_by
  stddev_samp: account_stddev_samp_order_by
  sum: account_sum_order_by
  var_pop: account_var_pop_order_by
  var_samp: account_var_samp_order_by
  variance: account_variance_order_by
}

# input type for inserting array relation for remote table "account"
input account_arr_rel_insert_input {
  data: [account_insert_input!]!
  on_conflict: account_on_conflict
}

# aggregate avg on columns
type account_avg_fields {
  employees: Float
  id: Float
  sailebot_id: Float
}

# order by avg() on columns of table "account"
input account_avg_order_by {
  employees: order_by
  id: order_by
  sailebot_id: order_by
}

# Boolean expression to filter rows from the table "account". All fields are combined with a logical 'AND'.
input account_bool_exp {
  _and: [account_bool_exp]
  _not: account_bool_exp
  _or: [account_bool_exp]
  address: String_comparison_exp
  domain: String_comparison_exp
  email: String_comparison_exp
  employees: Int_comparison_exp
  fax: String_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  phone: String_comparison_exp
  revenue: String_comparison_exp
  sailebot: sailebot_bool_exp
  sailebot_id: Int_comparison_exp
  state: String_comparison_exp
  targets: target_bool_exp
  website: String_comparison_exp
}

# unique or primary key constraints on table "account"
enum account_constraint {
  # unique or primary key constraint
  account_pkey
}

# input type for incrementing integer columne in table "account"
input account_inc_input {
  employees: Int
  id: Int
  sailebot_id: Int
}

# input type for inserting data into table "account"
input account_insert_input {
  address: String
  domain: String
  email: String
  employees: Int
  fax: String
  id: Int
  name: String
  phone: String
  revenue: String
  sailebot: sailebot_obj_rel_insert_input
  sailebot_id: Int
  state: String
  targets: target_arr_rel_insert_input
  website: String
}

# aggregate max on columns
type account_max_fields {
  address: String
  domain: String
  email: String
  employees: Int
  fax: String
  id: Int
  name: String
  phone: String
  revenue: String
  sailebot_id: Int
  state: String
  website: String
}

# order by max() on columns of table "account"
input account_max_order_by {
  address: order_by
  domain: order_by
  email: order_by
  employees: order_by
  fax: order_by
  id: order_by
  name: order_by
  phone: order_by
  revenue: order_by
  sailebot_id: order_by
  state: order_by
  website: order_by
}

# aggregate min on columns
type account_min_fields {
  address: String
  domain: String
  email: String
  employees: Int
  fax: String
  id: Int
  name: String
  phone: String
  revenue: String
  sailebot_id: Int
  state: String
  website: String
}

# order by min() on columns of table "account"
input account_min_order_by {
  address: order_by
  domain: order_by
  email: order_by
  employees: order_by
  fax: order_by
  id: order_by
  name: order_by
  phone: order_by
  revenue: order_by
  sailebot_id: order_by
  state: order_by
  website: order_by
}

# response of any mutation on the table "account"
type account_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [account!]!
}

# input type for inserting object relation for remote table "account"
input account_obj_rel_insert_input {
  data: account_insert_input!
  on_conflict: account_on_conflict
}

# on conflict condition type for table "account"
input account_on_conflict {
  constraint: account_constraint!
  update_columns: [account_update_column!]!
  where: account_bool_exp
}

# ordering options when selecting data from "account"
input account_order_by {
  address: order_by
  domain: order_by
  email: order_by
  employees: order_by
  fax: order_by
  id: order_by
  name: order_by
  phone: order_by
  revenue: order_by
  sailebot: sailebot_order_by
  sailebot_id: order_by
  state: order_by
  targets_aggregate: target_aggregate_order_by
  website: order_by
}

# select columns of table "account"
enum account_select_column {
  # column name
  address

  # column name
  domain

  # column name
  email

  # column name
  employees

  # column name
  fax

  # column name
  id

  # column name
  name

  # column name
  phone

  # column name
  revenue

  # column name
  sailebot_id

  # column name
  state

  # column name
  website
}

# input type for updating data in table "account"
input account_set_input {
  address: String
  domain: String
  email: String
  employees: Int
  fax: String
  id: Int
  name: String
  phone: String
  revenue: String
  sailebot_id: Int
  state: String
  website: String
}

# aggregate stddev on columns
type account_stddev_fields {
  employees: Float
  id: Float
  sailebot_id: Float
}

# order by stddev() on columns of table "account"
input account_stddev_order_by {
  employees: order_by
  id: order_by
  sailebot_id: order_by
}

# aggregate stddev_pop on columns
type account_stddev_pop_fields {
  employees: Float
  id: Float
  sailebot_id: Float
}

# order by stddev_pop() on columns of table "account"
input account_stddev_pop_order_by {
  employees: order_by
  id: order_by
  sailebot_id: order_by
}

# aggregate stddev_samp on columns
type account_stddev_samp_fields {
  employees: Float
  id: Float
  sailebot_id: Float
}

# order by stddev_samp() on columns of table "account"
input account_stddev_samp_order_by {
  employees: order_by
  id: order_by
  sailebot_id: order_by
}

# aggregate sum on columns
type account_sum_fields {
  employees: Int
  id: Int
  sailebot_id: Int
}

# order by sum() on columns of table "account"
input account_sum_order_by {
  employees: order_by
  id: order_by
  sailebot_id: order_by
}

# update columns of table "account"
enum account_update_column {
  # column name
  address

  # column name
  domain

  # column name
  email

  # column name
  employees

  # column name
  fax

  # column name
  id

  # column name
  name

  # column name
  phone

  # column name
  revenue

  # column name
  sailebot_id

  # column name
  state

  # column name
  website
}

# aggregate var_pop on columns
type account_var_pop_fields {
  employees: Float
  id: Float
  sailebot_id: Float
}

# order by var_pop() on columns of table "account"
input account_var_pop_order_by {
  employees: order_by
  id: order_by
  sailebot_id: order_by
}

# aggregate var_samp on columns
type account_var_samp_fields {
  employees: Float
  id: Float
  sailebot_id: Float
}

# order by var_samp() on columns of table "account"
input account_var_samp_order_by {
  employees: order_by
  id: order_by
  sailebot_id: order_by
}

# aggregate variance on columns
type account_variance_fields {
  employees: Float
  id: Float
  sailebot_id: Float
}

# order by variance() on columns of table "account"
input account_variance_order_by {
  employees: order_by
  id: order_by
  sailebot_id: order_by
}

# expression to compare columns of type Boolean. All fields are combined with logical 'AND'.
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

# columns and relationships of "campaign"
type campaign @model{
  description: String
  id: Int!
  name: String

  # An object relationship
  sailebot: sailebot!
  sailebot_id: Int!

  # An array relationship
  targets(
    # distinct select on columns
    distinct_on: [target_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [target_order_by!]

    # filter the rows returned
    where: target_bool_exp
  ): [target!]!

  # An aggregated array relationship
  targets_aggregate(
    # distinct select on columns
    distinct_on: [target_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [target_order_by!]

    # filter the rows returned
    where: target_bool_exp
  ): target_aggregate!

  # An array relationship
  templates(
    # distinct select on columns
    distinct_on: [template_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [template_order_by!]

    # filter the rows returned
    where: template_bool_exp
  ): [template!]!

  # An aggregated array relationship
  templates_aggregate(
    # distinct select on columns
    distinct_on: [template_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [template_order_by!]

    # filter the rows returned
    where: template_bool_exp
  ): template_aggregate!
}

# aggregated selection of "campaign"
type campaign_aggregate {
  aggregate: campaign_aggregate_fields
  nodes: [campaign!]!
}

# aggregate fields of "campaign"
type campaign_aggregate_fields {
  avg: campaign_avg_fields
  count(columns: [campaign_select_column!], distinct: Boolean): Int
  max: campaign_max_fields
  min: campaign_min_fields
  stddev: campaign_stddev_fields
  stddev_pop: campaign_stddev_pop_fields
  stddev_samp: campaign_stddev_samp_fields
  sum: campaign_sum_fields
  var_pop: campaign_var_pop_fields
  var_samp: campaign_var_samp_fields
  variance: campaign_variance_fields
}

# order by aggregate values of table "campaign"
input campaign_aggregate_order_by {
  avg: campaign_avg_order_by
  count: order_by
  max: campaign_max_order_by
  min: campaign_min_order_by
  stddev: campaign_stddev_order_by
  stddev_pop: campaign_stddev_pop_order_by
  stddev_samp: campaign_stddev_samp_order_by
  sum: campaign_sum_order_by
  var_pop: campaign_var_pop_order_by
  var_samp: campaign_var_samp_order_by
  variance: campaign_variance_order_by
}

# input type for inserting array relation for remote table "campaign"
input campaign_arr_rel_insert_input {
  data: [campaign_insert_input!]!
  on_conflict: campaign_on_conflict
}

# aggregate avg on columns
type campaign_avg_fields {
  id: Float
  sailebot_id: Float
}

# order by avg() on columns of table "campaign"
input campaign_avg_order_by {
  id: order_by
  sailebot_id: order_by
}

# Boolean expression to filter rows from the table "campaign". All fields are combined with a logical 'AND'.
input campaign_bool_exp {
  _and: [campaign_bool_exp]
  _not: campaign_bool_exp
  _or: [campaign_bool_exp]
  description: String_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  sailebot: sailebot_bool_exp
  sailebot_id: Int_comparison_exp
  targets: target_bool_exp
  templates: template_bool_exp
}

# unique or primary key constraints on table "campaign"
enum campaign_constraint {
  # unique or primary key constraint
  campaign_pkey
}

# input type for incrementing integer columne in table "campaign"
input campaign_inc_input {
  id: Int
  sailebot_id: Int
}

# input type for inserting data into table "campaign"
input campaign_insert_input {
  description: String
  id: Int
  name: String
  sailebot: sailebot_obj_rel_insert_input
  sailebot_id: Int
  targets: target_arr_rel_insert_input
  templates: template_arr_rel_insert_input
}

# aggregate max on columns
type campaign_max_fields {
  description: String
  id: Int
  name: String
  sailebot_id: Int
}

# order by max() on columns of table "campaign"
input campaign_max_order_by {
  description: order_by
  id: order_by
  name: order_by
  sailebot_id: order_by
}

# aggregate min on columns
type campaign_min_fields {
  description: String
  id: Int
  name: String
  sailebot_id: Int
}

# order by min() on columns of table "campaign"
input campaign_min_order_by {
  description: order_by
  id: order_by
  name: order_by
  sailebot_id: order_by
}

# response of any mutation on the table "campaign"
type campaign_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [campaign!]!
}

# input type for inserting object relation for remote table "campaign"
input campaign_obj_rel_insert_input {
  data: campaign_insert_input!
  on_conflict: campaign_on_conflict
}

# on conflict condition type for table "campaign"
input campaign_on_conflict {
  constraint: campaign_constraint!
  update_columns: [campaign_update_column!]!
  where: campaign_bool_exp
}

# ordering options when selecting data from "campaign"
input campaign_order_by {
  description: order_by
  id: order_by
  name: order_by
  sailebot: sailebot_order_by
  sailebot_id: order_by
  targets_aggregate: target_aggregate_order_by
  templates_aggregate: template_aggregate_order_by
}

# select columns of table "campaign"
enum campaign_select_column {
  # column name
  description

  # column name
  id

  # column name
  name

  # column name
  sailebot_id
}

# input type for updating data in table "campaign"
input campaign_set_input {
  description: String
  id: Int
  name: String
  sailebot_id: Int
}

# aggregate stddev on columns
type campaign_stddev_fields {
  id: Float
  sailebot_id: Float
}

# order by stddev() on columns of table "campaign"
input campaign_stddev_order_by {
  id: order_by
  sailebot_id: order_by
}

# aggregate stddev_pop on columns
type campaign_stddev_pop_fields {
  id: Float
  sailebot_id: Float
}

# order by stddev_pop() on columns of table "campaign"
input campaign_stddev_pop_order_by {
  id: order_by
  sailebot_id: order_by
}

# aggregate stddev_samp on columns
type campaign_stddev_samp_fields {
  id: Float
  sailebot_id: Float
}

# order by stddev_samp() on columns of table "campaign"
input campaign_stddev_samp_order_by {
  id: order_by
  sailebot_id: order_by
}

# aggregate sum on columns
type campaign_sum_fields {
  id: Int
  sailebot_id: Int
}

# order by sum() on columns of table "campaign"
input campaign_sum_order_by {
  id: order_by
  sailebot_id: order_by
}

# update columns of table "campaign"
enum campaign_update_column {
  # column name
  description

  # column name
  id

  # column name
  name

  # column name
  sailebot_id
}

# aggregate var_pop on columns
type campaign_var_pop_fields {
  id: Float
  sailebot_id: Float
}

# order by var_pop() on columns of table "campaign"
input campaign_var_pop_order_by {
  id: order_by
  sailebot_id: order_by
}

# aggregate var_samp on columns
type campaign_var_samp_fields {
  id: Float
  sailebot_id: Float
}

# order by var_samp() on columns of table "campaign"
input campaign_var_samp_order_by {
  id: order_by
  sailebot_id: order_by
}

# aggregate variance on columns
type campaign_variance_fields {
  id: Float
  sailebot_id: Float
}

# order by variance() on columns of table "campaign"
input campaign_variance_order_by {
  id: order_by
  sailebot_id: order_by
}

# columns and relationships of "client"
type client @model{
  # An object relationship
  company: company!
  company_id: Int!
  id: Int!
  name: String

  # An array relationship
  requirements(
    # distinct select on columns
    distinct_on: [requirement_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [requirement_order_by!]

    # filter the rows returned
    where: requirement_bool_exp
  ): [requirement!]!

  # An aggregated array relationship
  requirements_aggregate(
    # distinct select on columns
    distinct_on: [requirement_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [requirement_order_by!]

    # filter the rows returned
    where: requirement_bool_exp
  ): requirement_aggregate!

  # An array relationship
  sailebots(
    # distinct select on columns
    distinct_on: [sailebot_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sailebot_order_by!]

    # filter the rows returned
    where: sailebot_bool_exp
  ): [sailebot!]!

  # An aggregated array relationship
  sailebots_aggregate(
    # distinct select on columns
    distinct_on: [sailebot_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sailebot_order_by!]

    # filter the rows returned
    where: sailebot_bool_exp
  ): sailebot_aggregate!
}

# aggregated selection of "client"
type client_aggregate {
  aggregate: client_aggregate_fields
  nodes: [client!]!
}

# aggregate fields of "client"
type client_aggregate_fields {
  avg: client_avg_fields
  count(columns: [client_select_column!], distinct: Boolean): Int
  max: client_max_fields
  min: client_min_fields
  stddev: client_stddev_fields
  stddev_pop: client_stddev_pop_fields
  stddev_samp: client_stddev_samp_fields
  sum: client_sum_fields
  var_pop: client_var_pop_fields
  var_samp: client_var_samp_fields
  variance: client_variance_fields
}

# order by aggregate values of table "client"
input client_aggregate_order_by {
  avg: client_avg_order_by
  count: order_by
  max: client_max_order_by
  min: client_min_order_by
  stddev: client_stddev_order_by
  stddev_pop: client_stddev_pop_order_by
  stddev_samp: client_stddev_samp_order_by
  sum: client_sum_order_by
  var_pop: client_var_pop_order_by
  var_samp: client_var_samp_order_by
  variance: client_variance_order_by
}

# input type for inserting array relation for remote table "client"
input client_arr_rel_insert_input {
  data: [client_insert_input!]!
  on_conflict: client_on_conflict
}

# aggregate avg on columns
type client_avg_fields {
  company_id: Float
  id: Float
}

# order by avg() on columns of table "client"
input client_avg_order_by {
  company_id: order_by
  id: order_by
}

# Boolean expression to filter rows from the table "client". All fields are combined with a logical 'AND'.
input client_bool_exp {
  _and: [client_bool_exp]
  _not: client_bool_exp
  _or: [client_bool_exp]
  company: company_bool_exp
  company_id: Int_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  requirements: requirement_bool_exp
  sailebots: sailebot_bool_exp
}

# unique or primary key constraints on table "client"
enum client_constraint {
  # unique or primary key constraint
  client_pkey
}

# input type for incrementing integer columne in table "client"
input client_inc_input {
  company_id: Int
  id: Int
}

# input type for inserting data into table "client"
input client_insert_input {
  company: company_obj_rel_insert_input
  company_id: Int
  id: Int
  name: String
  requirements: requirement_arr_rel_insert_input
  sailebots: sailebot_arr_rel_insert_input
}

# aggregate max on columns
type client_max_fields {
  company_id: Int
  id: Int
  name: String
}

# order by max() on columns of table "client"
input client_max_order_by {
  company_id: order_by
  id: order_by
  name: order_by
}

# aggregate min on columns
type client_min_fields {
  company_id: Int
  id: Int
  name: String
}

# order by min() on columns of table "client"
input client_min_order_by {
  company_id: order_by
  id: order_by
  name: order_by
}

# response of any mutation on the table "client"
type client_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [client!]!
}

# input type for inserting object relation for remote table "client"
input client_obj_rel_insert_input {
  data: client_insert_input!
  on_conflict: client_on_conflict
}

# on conflict condition type for table "client"
input client_on_conflict {
  constraint: client_constraint!
  update_columns: [client_update_column!]!
  where: client_bool_exp
}

# ordering options when selecting data from "client"
input client_order_by {
  company: company_order_by
  company_id: order_by
  id: order_by
  name: order_by
  requirements_aggregate: requirement_aggregate_order_by
  sailebots_aggregate: sailebot_aggregate_order_by
}

# select columns of table "client"
enum client_select_column {
  # column name
  company_id

  # column name
  id

  # column name
  name
}

# input type for updating data in table "client"
input client_set_input {
  company_id: Int
  id: Int
  name: String
}

# aggregate stddev on columns
type client_stddev_fields {
  company_id: Float
  id: Float
}

# order by stddev() on columns of table "client"
input client_stddev_order_by {
  company_id: order_by
  id: order_by
}

# aggregate stddev_pop on columns
type client_stddev_pop_fields {
  company_id: Float
  id: Float
}

# order by stddev_pop() on columns of table "client"
input client_stddev_pop_order_by {
  company_id: order_by
  id: order_by
}

# aggregate stddev_samp on columns
type client_stddev_samp_fields {
  company_id: Float
  id: Float
}

# order by stddev_samp() on columns of table "client"
input client_stddev_samp_order_by {
  company_id: order_by
  id: order_by
}

# aggregate sum on columns
type client_sum_fields {
  company_id: Int
  id: Int
}

# order by sum() on columns of table "client"
input client_sum_order_by {
  company_id: order_by
  id: order_by
}

# update columns of table "client"
enum client_update_column {
  # column name
  company_id

  # column name
  id

  # column name
  name
}

# aggregate var_pop on columns
type client_var_pop_fields {
  company_id: Float
  id: Float
}

# order by var_pop() on columns of table "client"
input client_var_pop_order_by {
  company_id: order_by
  id: order_by
}

# aggregate var_samp on columns
type client_var_samp_fields {
  company_id: Float
  id: Float
}

# order by var_samp() on columns of table "client"
input client_var_samp_order_by {
  company_id: order_by
  id: order_by
}

# aggregate variance on columns
type client_variance_fields {
  company_id: Float
  id: Float
}

# order by variance() on columns of table "client"
input client_variance_order_by {
  company_id: order_by
  id: order_by
}

# columns and relationships of "company"
type company @model{
  address: String

  # An array relationship
  clients(
    # distinct select on columns
    distinct_on: [client_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [client_order_by!]

    # filter the rows returned
    where: client_bool_exp
  ): [client!]!

  # An aggregated array relationship
  clients_aggregate(
    # distinct select on columns
    distinct_on: [client_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [client_order_by!]

    # filter the rows returned
    where: client_bool_exp
  ): client_aggregate!
  email: String!
  fax: String
  id: Int!
  name: String
  phone: String
  website: String
}

# aggregated selection of "company"
type company_aggregate {
  aggregate: company_aggregate_fields
  nodes: [company!]!
}

# aggregate fields of "company"
type company_aggregate_fields {
  avg: company_avg_fields
  count(columns: [company_select_column!], distinct: Boolean): Int
  max: company_max_fields
  min: company_min_fields
  stddev: company_stddev_fields
  stddev_pop: company_stddev_pop_fields
  stddev_samp: company_stddev_samp_fields
  sum: company_sum_fields
  var_pop: company_var_pop_fields
  var_samp: company_var_samp_fields
  variance: company_variance_fields
}

# order by aggregate values of table "company"
input company_aggregate_order_by {
  avg: company_avg_order_by
  count: order_by
  max: company_max_order_by
  min: company_min_order_by
  stddev: company_stddev_order_by
  stddev_pop: company_stddev_pop_order_by
  stddev_samp: company_stddev_samp_order_by
  sum: company_sum_order_by
  var_pop: company_var_pop_order_by
  var_samp: company_var_samp_order_by
  variance: company_variance_order_by
}

# input type for inserting array relation for remote table "company"
input company_arr_rel_insert_input {
  data: [company_insert_input!]!
  on_conflict: company_on_conflict
}

# aggregate avg on columns
type company_avg_fields {
  id: Float
}

# order by avg() on columns of table "company"
input company_avg_order_by {
  id: order_by
}

# Boolean expression to filter rows from the table "company". All fields are combined with a logical 'AND'.
input company_bool_exp {
  _and: [company_bool_exp]
  _not: company_bool_exp
  _or: [company_bool_exp]
  address: String_comparison_exp
  clients: client_bool_exp
  email: String_comparison_exp
  fax: String_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  phone: String_comparison_exp
  website: String_comparison_exp
}

# unique or primary key constraints on table "company"
enum company_constraint {
  # unique or primary key constraint
  company_email_key

  # unique or primary key constraint
  company_pkey
}

# input type for incrementing integer columne in table "company"
input company_inc_input {
  id: Int
}

# input type for inserting data into table "company"
input company_insert_input {
  address: String
  clients: client_arr_rel_insert_input
  email: String
  fax: String
  id: Int
  name: String
  phone: String
  website: String
}

# aggregate max on columns
type company_max_fields {
  address: String
  email: String
  fax: String
  id: Int
  name: String
  phone: String
  website: String
}

# order by max() on columns of table "company"
input company_max_order_by {
  address: order_by
  email: order_by
  fax: order_by
  id: order_by
  name: order_by
  phone: order_by
  website: order_by
}

# aggregate min on columns
type company_min_fields {
  address: String
  email: String
  fax: String
  id: Int
  name: String
  phone: String
  website: String
}

# order by min() on columns of table "company"
input company_min_order_by {
  address: order_by
  email: order_by
  fax: order_by
  id: order_by
  name: order_by
  phone: order_by
  website: order_by
}

# response of any mutation on the table "company"
type company_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [company!]!
}

# input type for inserting object relation for remote table "company"
input company_obj_rel_insert_input {
  data: company_insert_input!
  on_conflict: company_on_conflict
}

# on conflict condition type for table "company"
input company_on_conflict {
  constraint: company_constraint!
  update_columns: [company_update_column!]!
  where: company_bool_exp
}

# ordering options when selecting data from "company"
input company_order_by {
  address: order_by
  clients_aggregate: client_aggregate_order_by
  email: order_by
  fax: order_by
  id: order_by
  name: order_by
  phone: order_by
  website: order_by
}

# select columns of table "company"
enum company_select_column {
  # column name
  address

  # column name
  email

  # column name
  fax

  # column name
  id

  # column name
  name

  # column name
  phone

  # column name
  website
}

# input type for updating data in table "company"
input company_set_input {
  address: String
  email: String
  fax: String
  id: Int
  name: String
  phone: String
  website: String
}

# aggregate stddev on columns
type company_stddev_fields {
  id: Float
}

# order by stddev() on columns of table "company"
input company_stddev_order_by {
  id: order_by
}

# aggregate stddev_pop on columns
type company_stddev_pop_fields {
  id: Float
}

# order by stddev_pop() on columns of table "company"
input company_stddev_pop_order_by {
  id: order_by
}

# aggregate stddev_samp on columns
type company_stddev_samp_fields {
  id: Float
}

# order by stddev_samp() on columns of table "company"
input company_stddev_samp_order_by {
  id: order_by
}

# aggregate sum on columns
type company_sum_fields {
  id: Int
}

# order by sum() on columns of table "company"
input company_sum_order_by {
  id: order_by
}

# update columns of table "company"
enum company_update_column {
  # column name
  address

  # column name
  email

  # column name
  fax

  # column name
  id

  # column name
  name

  # column name
  phone

  # column name
  website
}

# aggregate var_pop on columns
type company_var_pop_fields {
  id: Float
}

# order by var_pop() on columns of table "company"
input company_var_pop_order_by {
  id: order_by
}

# aggregate var_samp on columns
type company_var_samp_fields {
  id: Float
}

# order by var_samp() on columns of table "company"
input company_var_samp_order_by {
  id: order_by
}

# aggregate variance on columns
type company_variance_fields {
  id: Float
}

# order by variance() on columns of table "company"
input company_variance_order_by {
  id: order_by
}

# columns and relationships of "domains"
type domains @model{
  active: Boolean!
  dns: String
  host: String
  id: Int!
  ip: String
  name: String
  provider: String

  # An object relationship
  sailebot: sailebot!
  sailebot_id: Int!
  smtp: String
}

# aggregated selection of "domains"
type domains_aggregate {
  aggregate: domains_aggregate_fields
  nodes: [domains!]!
}

# aggregate fields of "domains"
type domains_aggregate_fields {
  avg: domains_avg_fields
  count(columns: [domains_select_column!], distinct: Boolean): Int
  max: domains_max_fields
  min: domains_min_fields
  stddev: domains_stddev_fields
  stddev_pop: domains_stddev_pop_fields
  stddev_samp: domains_stddev_samp_fields
  sum: domains_sum_fields
  var_pop: domains_var_pop_fields
  var_samp: domains_var_samp_fields
  variance: domains_variance_fields
}

# order by aggregate values of table "domains"
input domains_aggregate_order_by {
  avg: domains_avg_order_by
  count: order_by
  max: domains_max_order_by
  min: domains_min_order_by
  stddev: domains_stddev_order_by
  stddev_pop: domains_stddev_pop_order_by
  stddev_samp: domains_stddev_samp_order_by
  sum: domains_sum_order_by
  var_pop: domains_var_pop_order_by
  var_samp: domains_var_samp_order_by
  variance: domains_variance_order_by
}

# input type for inserting array relation for remote table "domains"
input domains_arr_rel_insert_input {
  data: [domains_insert_input!]!
  on_conflict: domains_on_conflict
}

# aggregate avg on columns
type domains_avg_fields {
  id: Float
  sailebot_id: Float
}

# order by avg() on columns of table "domains"
input domains_avg_order_by {
  id: order_by
  sailebot_id: order_by
}

# Boolean expression to filter rows from the table "domains". All fields are combined with a logical 'AND'.
input domains_bool_exp {
  _and: [domains_bool_exp]
  _not: domains_bool_exp
  _or: [domains_bool_exp]
  active: Boolean_comparison_exp
  dns: String_comparison_exp
  host: String_comparison_exp
  id: Int_comparison_exp
  ip: String_comparison_exp
  name: String_comparison_exp
  provider: String_comparison_exp
  sailebot: sailebot_bool_exp
  sailebot_id: Int_comparison_exp
  smtp: String_comparison_exp
}

# unique or primary key constraints on table "domains"
enum domains_constraint {
  # unique or primary key constraint
  domains_pkey
}

# input type for incrementing integer columne in table "domains"
input domains_inc_input {
  id: Int
  sailebot_id: Int
}

# input type for inserting data into table "domains"
input domains_insert_input {
  active: Boolean
  dns: String
  host: String
  id: Int
  ip: String
  name: String
  provider: String
  sailebot: sailebot_obj_rel_insert_input
  sailebot_id: Int
  smtp: String
}

# aggregate max on columns
type domains_max_fields {
  dns: String
  host: String
  id: Int
  ip: String
  name: String
  provider: String
  sailebot_id: Int
  smtp: String
}

# order by max() on columns of table "domains"
input domains_max_order_by {
  dns: order_by
  host: order_by
  id: order_by
  ip: order_by
  name: order_by
  provider: order_by
  sailebot_id: order_by
  smtp: order_by
}

# aggregate min on columns
type domains_min_fields {
  dns: String
  host: String
  id: Int
  ip: String
  name: String
  provider: String
  sailebot_id: Int
  smtp: String
}

# order by min() on columns of table "domains"
input domains_min_order_by {
  dns: order_by
  host: order_by
  id: order_by
  ip: order_by
  name: order_by
  provider: order_by
  sailebot_id: order_by
  smtp: order_by
}

# response of any mutation on the table "domains"
type domains_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [domains!]!
}

# input type for inserting object relation for remote table "domains"
input domains_obj_rel_insert_input {
  data: domains_insert_input!
  on_conflict: domains_on_conflict
}

# on conflict condition type for table "domains"
input domains_on_conflict {
  constraint: domains_constraint!
  update_columns: [domains_update_column!]!
  where: domains_bool_exp
}

# ordering options when selecting data from "domains"
input domains_order_by {
  active: order_by
  dns: order_by
  host: order_by
  id: order_by
  ip: order_by
  name: order_by
  provider: order_by
  sailebot: sailebot_order_by
  sailebot_id: order_by
  smtp: order_by
}

# select columns of table "domains"
enum domains_select_column {
  # column name
  active

  # column name
  dns

  # column name
  host

  # column name
  id

  # column name
  ip

  # column name
  name

  # column name
  provider

  # column name
  sailebot_id

  # column name
  smtp
}

# input type for updating data in table "domains"
input domains_set_input {
  active: Boolean
  dns: String
  host: String
  id: Int
  ip: String
  name: String
  provider: String
  sailebot_id: Int
  smtp: String
}

# aggregate stddev on columns
type domains_stddev_fields {
  id: Float
  sailebot_id: Float
}

# order by stddev() on columns of table "domains"
input domains_stddev_order_by {
  id: order_by
  sailebot_id: order_by
}

# aggregate stddev_pop on columns
type domains_stddev_pop_fields {
  id: Float
  sailebot_id: Float
}

# order by stddev_pop() on columns of table "domains"
input domains_stddev_pop_order_by {
  id: order_by
  sailebot_id: order_by
}

# aggregate stddev_samp on columns
type domains_stddev_samp_fields {
  id: Float
  sailebot_id: Float
}

# order by stddev_samp() on columns of table "domains"
input domains_stddev_samp_order_by {
  id: order_by
  sailebot_id: order_by
}

# aggregate sum on columns
type domains_sum_fields {
  id: Int
  sailebot_id: Int
}

# order by sum() on columns of table "domains"
input domains_sum_order_by {
  id: order_by
  sailebot_id: order_by
}

# update columns of table "domains"
enum domains_update_column {
  # column name
  active

  # column name
  dns

  # column name
  host

  # column name
  id

  # column name
  ip

  # column name
  name

  # column name
  provider

  # column name
  sailebot_id

  # column name
  smtp
}

# aggregate var_pop on columns
type domains_var_pop_fields {
  id: Float
  sailebot_id: Float
}

# order by var_pop() on columns of table "domains"
input domains_var_pop_order_by {
  id: order_by
  sailebot_id: order_by
}

# aggregate var_samp on columns
type domains_var_samp_fields {
  id: Float
  sailebot_id: Float
}

# order by var_samp() on columns of table "domains"
input domains_var_samp_order_by {
  id: order_by
  sailebot_id: order_by
}

# aggregate variance on columns
type domains_variance_fields {
  id: Float
  sailebot_id: Float
}

# order by variance() on columns of table "domains"
input domains_variance_order_by {
  id: order_by
  sailebot_id: order_by
}

# columns and relationships of "event"
type event @model{
  body: String
  cc: String
  date: String
  id: Int!
  label: String
  sender: String
  subject: String

  # An object relationship
  target: target!
  target_id: Int!
  to: String
}

# aggregated selection of "event"
type event_aggregate {
  aggregate: event_aggregate_fields
  nodes: [event!]!
}

# aggregate fields of "event"
type event_aggregate_fields {
  avg: event_avg_fields
  count(columns: [event_select_column!], distinct: Boolean): Int
  max: event_max_fields
  min: event_min_fields
  stddev: event_stddev_fields
  stddev_pop: event_stddev_pop_fields
  stddev_samp: event_stddev_samp_fields
  sum: event_sum_fields
  var_pop: event_var_pop_fields
  var_samp: event_var_samp_fields
  variance: event_variance_fields
}

# order by aggregate values of table "event"
input event_aggregate_order_by {
  avg: event_avg_order_by
  count: order_by
  max: event_max_order_by
  min: event_min_order_by
  stddev: event_stddev_order_by
  stddev_pop: event_stddev_pop_order_by
  stddev_samp: event_stddev_samp_order_by
  sum: event_sum_order_by
  var_pop: event_var_pop_order_by
  var_samp: event_var_samp_order_by
  variance: event_variance_order_by
}

# input type for inserting array relation for remote table "event"
input event_arr_rel_insert_input {
  data: [event_insert_input!]!
  on_conflict: event_on_conflict
}

# aggregate avg on columns
type event_avg_fields {
  id: Float
  target_id: Float
}

# order by avg() on columns of table "event"
input event_avg_order_by {
  id: order_by
  target_id: order_by
}

# Boolean expression to filter rows from the table "event". All fields are combined with a logical 'AND'.
input event_bool_exp {
  _and: [event_bool_exp]
  _not: event_bool_exp
  _or: [event_bool_exp]
  body: String_comparison_exp
  cc: String_comparison_exp
  date: String_comparison_exp
  id: Int_comparison_exp
  label: String_comparison_exp
  sender: String_comparison_exp
  subject: String_comparison_exp
  target: target_bool_exp
  target_id: Int_comparison_exp
  to: String_comparison_exp
}

# unique or primary key constraints on table "event"
enum event_constraint {
  # unique or primary key constraint
  event_pkey
}

# input type for incrementing integer columne in table "event"
input event_inc_input {
  id: Int
  target_id: Int
}

# input type for inserting data into table "event"
input event_insert_input {
  body: String
  cc: String
  date: String
  id: Int
  label: String
  sender: String
  subject: String
  target: target_obj_rel_insert_input
  target_id: Int
  to: String
}

# aggregate max on columns
type event_max_fields {
  body: String
  cc: String
  date: String
  id: Int
  label: String
  sender: String
  subject: String
  target_id: Int
  to: String
}

# order by max() on columns of table "event"
input event_max_order_by {
  body: order_by
  cc: order_by
  date: order_by
  id: order_by
  label: order_by
  sender: order_by
  subject: order_by
  target_id: order_by
  to: order_by
}

# aggregate min on columns
type event_min_fields {
  body: String
  cc: String
  date: String
  id: Int
  label: String
  sender: String
  subject: String
  target_id: Int
  to: String
}

# order by min() on columns of table "event"
input event_min_order_by {
  body: order_by
  cc: order_by
  date: order_by
  id: order_by
  label: order_by
  sender: order_by
  subject: order_by
  target_id: order_by
  to: order_by
}

# response of any mutation on the table "event"
type event_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [event!]!
}

# input type for inserting object relation for remote table "event"
input event_obj_rel_insert_input {
  data: event_insert_input!
  on_conflict: event_on_conflict
}

# on conflict condition type for table "event"
input event_on_conflict {
  constraint: event_constraint!
  update_columns: [event_update_column!]!
  where: event_bool_exp
}

# ordering options when selecting data from "event"
input event_order_by {
  body: order_by
  cc: order_by
  date: order_by
  id: order_by
  label: order_by
  sender: order_by
  subject: order_by
  target: target_order_by
  target_id: order_by
  to: order_by
}

# select columns of table "event"
enum event_select_column {
  # column name
  body

  # column name
  cc

  # column name
  date

  # column name
  id

  # column name
  label

  # column name
  sender

  # column name
  subject

  # column name
  target_id

  # column name
  to
}

# input type for updating data in table "event"
input event_set_input {
  body: String
  cc: String
  date: String
  id: Int
  label: String
  sender: String
  subject: String
  target_id: Int
  to: String
}

# aggregate stddev on columns
type event_stddev_fields {
  id: Float
  target_id: Float
}

# order by stddev() on columns of table "event"
input event_stddev_order_by {
  id: order_by
  target_id: order_by
}

# aggregate stddev_pop on columns
type event_stddev_pop_fields {
  id: Float
  target_id: Float
}

# order by stddev_pop() on columns of table "event"
input event_stddev_pop_order_by {
  id: order_by
  target_id: order_by
}

# aggregate stddev_samp on columns
type event_stddev_samp_fields {
  id: Float
  target_id: Float
}

# order by stddev_samp() on columns of table "event"
input event_stddev_samp_order_by {
  id: order_by
  target_id: order_by
}

# aggregate sum on columns
type event_sum_fields {
  id: Int
  target_id: Int
}

# order by sum() on columns of table "event"
input event_sum_order_by {
  id: order_by
  target_id: order_by
}

# update columns of table "event"
enum event_update_column {
  # column name
  body

  # column name
  cc

  # column name
  date

  # column name
  id

  # column name
  label

  # column name
  sender

  # column name
  subject

  # column name
  target_id

  # column name
  to
}

# aggregate var_pop on columns
type event_var_pop_fields {
  id: Float
  target_id: Float
}

# order by var_pop() on columns of table "event"
input event_var_pop_order_by {
  id: order_by
  target_id: order_by
}

# aggregate var_samp on columns
type event_var_samp_fields {
  id: Float
  target_id: Float
}

# order by var_samp() on columns of table "event"
input event_var_samp_order_by {
  id: order_by
  target_id: order_by
}

# aggregate variance on columns
type event_variance_fields {
  id: Float
  target_id: Float
}

# order by variance() on columns of table "event"
input event_variance_order_by {
  id: order_by
  target_id: order_by
}

# expression to compare columns of type Int. All fields are combined with logical 'AND'.
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

# mutation root
type mutation_root {
  # delete data from the table: "account"
  delete_account(
    # filter the rows which have to be deleted
    where: account_bool_exp!
  ): account_mutation_response

  # delete data from the table: "campaign"
  delete_campaign(
    # filter the rows which have to be deleted
    where: campaign_bool_exp!
  ): campaign_mutation_response

  # delete data from the table: "client"
  delete_client(
    # filter the rows which have to be deleted
    where: client_bool_exp!
  ): client_mutation_response

  # delete data from the table: "company"
  delete_company(
    # filter the rows which have to be deleted
    where: company_bool_exp!
  ): company_mutation_response

  # delete data from the table: "domains"
  delete_domains(
    # filter the rows which have to be deleted
    where: domains_bool_exp!
  ): domains_mutation_response

  # delete data from the table: "event"
  delete_event(
    # filter the rows which have to be deleted
    where: event_bool_exp!
  ): event_mutation_response

  # delete data from the table: "requirement"
  delete_requirement(
    # filter the rows which have to be deleted
    where: requirement_bool_exp!
  ): requirement_mutation_response

  # delete data from the table: "sailebot"
  delete_sailebot(
    # filter the rows which have to be deleted
    where: sailebot_bool_exp!
  ): sailebot_mutation_response

  # delete data from the table: "schedule"
  delete_schedule(
    # filter the rows which have to be deleted
    where: schedule_bool_exp!
  ): schedule_mutation_response

  # delete data from the table: "target"
  delete_target(
    # filter the rows which have to be deleted
    where: target_bool_exp!
  ): target_mutation_response

  # delete data from the table: "template"
  delete_template(
    # filter the rows which have to be deleted
    where: template_bool_exp!
  ): template_mutation_response

  # insert data into the table: "account"
  insert_account(
    # the rows to be inserted
    objects: [account_insert_input!]!

    # on conflict condition
    on_conflict: account_on_conflict
  ): account_mutation_response

  # insert data into the table: "campaign"
  insert_campaign(
    # the rows to be inserted
    objects: [campaign_insert_input!]!

    # on conflict condition
    on_conflict: campaign_on_conflict
  ): campaign_mutation_response

  # insert data into the table: "client"
  insert_client(
    # the rows to be inserted
    objects: [client_insert_input!]!

    # on conflict condition
    on_conflict: client_on_conflict
  ): client_mutation_response

  # insert data into the table: "company"
  insert_company(
    # the rows to be inserted
    objects: [company_insert_input!]!

    # on conflict condition
    on_conflict: company_on_conflict
  ): company_mutation_response

  # insert data into the table: "domains"
  insert_domains(
    # the rows to be inserted
    objects: [domains_insert_input!]!

    # on conflict condition
    on_conflict: domains_on_conflict
  ): domains_mutation_response

  # insert data into the table: "event"
  insert_event(
    # the rows to be inserted
    objects: [event_insert_input!]!

    # on conflict condition
    on_conflict: event_on_conflict
  ): event_mutation_response

  # insert data into the table: "requirement"
  insert_requirement(
    # the rows to be inserted
    objects: [requirement_insert_input!]!

    # on conflict condition
    on_conflict: requirement_on_conflict
  ): requirement_mutation_response

  # insert data into the table: "sailebot"
  insert_sailebot(
    # the rows to be inserted
    objects: [sailebot_insert_input!]!

    # on conflict condition
    on_conflict: sailebot_on_conflict
  ): sailebot_mutation_response

  # insert data into the table: "schedule"
  insert_schedule(
    # the rows to be inserted
    objects: [schedule_insert_input!]!

    # on conflict condition
    on_conflict: schedule_on_conflict
  ): schedule_mutation_response

  # insert data into the table: "target"
  insert_target(
    # the rows to be inserted
    objects: [target_insert_input!]!

    # on conflict condition
    on_conflict: target_on_conflict
  ): target_mutation_response

  # insert data into the table: "template"
  insert_template(
    # the rows to be inserted
    objects: [template_insert_input!]!

    # on conflict condition
    on_conflict: template_on_conflict
  ): template_mutation_response

  # update data of the table: "account"
  update_account(
    # increments the integer columns with given value of the filtered values
    _inc: account_inc_input

    # sets the columns of the filtered rows to the given values
    _set: account_set_input

    # filter the rows which have to be updated
    where: account_bool_exp!
  ): account_mutation_response

  # update data of the table: "campaign"
  update_campaign(
    # increments the integer columns with given value of the filtered values
    _inc: campaign_inc_input

    # sets the columns of the filtered rows to the given values
    _set: campaign_set_input

    # filter the rows which have to be updated
    where: campaign_bool_exp!
  ): campaign_mutation_response

  # update data of the table: "client"
  update_client(
    # increments the integer columns with given value of the filtered values
    _inc: client_inc_input

    # sets the columns of the filtered rows to the given values
    _set: client_set_input

    # filter the rows which have to be updated
    where: client_bool_exp!
  ): client_mutation_response

  # update data of the table: "company"
  update_company(
    # increments the integer columns with given value of the filtered values
    _inc: company_inc_input

    # sets the columns of the filtered rows to the given values
    _set: company_set_input

    # filter the rows which have to be updated
    where: company_bool_exp!
  ): company_mutation_response

  # update data of the table: "domains"
  update_domains(
    # increments the integer columns with given value of the filtered values
    _inc: domains_inc_input

    # sets the columns of the filtered rows to the given values
    _set: domains_set_input

    # filter the rows which have to be updated
    where: domains_bool_exp!
  ): domains_mutation_response

  # update data of the table: "event"
  update_event(
    # increments the integer columns with given value of the filtered values
    _inc: event_inc_input

    # sets the columns of the filtered rows to the given values
    _set: event_set_input

    # filter the rows which have to be updated
    where: event_bool_exp!
  ): event_mutation_response

  # update data of the table: "requirement"
  update_requirement(
    # increments the integer columns with given value of the filtered values
    _inc: requirement_inc_input

    # sets the columns of the filtered rows to the given values
    _set: requirement_set_input

    # filter the rows which have to be updated
    where: requirement_bool_exp!
  ): requirement_mutation_response

  # update data of the table: "sailebot"
  update_sailebot(
    # increments the integer columns with given value of the filtered values
    _inc: sailebot_inc_input

    # sets the columns of the filtered rows to the given values
    _set: sailebot_set_input

    # filter the rows which have to be updated
    where: sailebot_bool_exp!
  ): sailebot_mutation_response

  # update data of the table: "schedule"
  update_schedule(
    # increments the integer columns with given value of the filtered values
    _inc: schedule_inc_input

    # sets the columns of the filtered rows to the given values
    _set: schedule_set_input

    # filter the rows which have to be updated
    where: schedule_bool_exp!
  ): schedule_mutation_response

  # update data of the table: "target"
  update_target(
    # increments the integer columns with given value of the filtered values
    _inc: target_inc_input

    # sets the columns of the filtered rows to the given values
    _set: target_set_input

    # filter the rows which have to be updated
    where: target_bool_exp!
  ): target_mutation_response

  # update data of the table: "template"
  update_template(
    # increments the integer columns with given value of the filtered values
    _inc: template_inc_input

    # sets the columns of the filtered rows to the given values
    _set: template_set_input

    # filter the rows which have to be updated
    where: template_bool_exp!
  ): template_mutation_response
}

# column ordering options
enum order_by {
  # in the ascending order, nulls last
  asc

  # in the ascending order, nulls first
  asc_nulls_first

  # in the ascending order, nulls last
  asc_nulls_last

  # in the descending order, nulls first
  desc

  # in the descending order, nulls first
  desc_nulls_first

  # in the descending order, nulls last
  desc_nulls_last
}

# query root
type query_root {
  # fetch data from the table: "account"
  account(
    # distinct select on columns
    distinct_on: [account_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_order_by!]

    # filter the rows returned
    where: account_bool_exp
  ): [account!]!

  # fetch aggregated fields from the table: "account"
  account_aggregate(
    # distinct select on columns
    distinct_on: [account_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_order_by!]

    # filter the rows returned
    where: account_bool_exp
  ): account_aggregate!

  # fetch data from the table: "account" using primary key columns
  account_by_pk(id: Int!): account

  # fetch data from the table: "campaign"
  campaign(
    # distinct select on columns
    distinct_on: [campaign_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [campaign_order_by!]

    # filter the rows returned
    where: campaign_bool_exp
  ): [campaign!]!

  # fetch aggregated fields from the table: "campaign"
  campaign_aggregate(
    # distinct select on columns
    distinct_on: [campaign_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [campaign_order_by!]

    # filter the rows returned
    where: campaign_bool_exp
  ): campaign_aggregate!

  # fetch data from the table: "campaign" using primary key columns
  campaign_by_pk(id: Int!): campaign

  # fetch data from the table: "client"
  client(
    # distinct select on columns
    distinct_on: [client_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [client_order_by!]

    # filter the rows returned
    where: client_bool_exp
  ): [client!]!

  # fetch aggregated fields from the table: "client"
  client_aggregate(
    # distinct select on columns
    distinct_on: [client_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [client_order_by!]

    # filter the rows returned
    where: client_bool_exp
  ): client_aggregate!

  # fetch data from the table: "client" using primary key columns
  client_by_pk(id: Int!): client

  # fetch data from the table: "company"
  company(
    # distinct select on columns
    distinct_on: [company_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [company_order_by!]

    # filter the rows returned
    where: company_bool_exp
  ): [company!]!

  # fetch aggregated fields from the table: "company"
  company_aggregate(
    # distinct select on columns
    distinct_on: [company_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [company_order_by!]

    # filter the rows returned
    where: company_bool_exp
  ): company_aggregate!

  # fetch data from the table: "company" using primary key columns
  company_by_pk(id: Int!): company

  # fetch data from the table: "domains"
  domains(
    # distinct select on columns
    distinct_on: [domains_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [domains_order_by!]

    # filter the rows returned
    where: domains_bool_exp
  ): [domains!]!

  # fetch aggregated fields from the table: "domains"
  domains_aggregate(
    # distinct select on columns
    distinct_on: [domains_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [domains_order_by!]

    # filter the rows returned
    where: domains_bool_exp
  ): domains_aggregate!

  # fetch data from the table: "domains" using primary key columns
  domains_by_pk(id: Int!): domains

  # fetch data from the table: "event"
  event(
    # distinct select on columns
    distinct_on: [event_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_order_by!]

    # filter the rows returned
    where: event_bool_exp
  ): [event!]!

  # fetch aggregated fields from the table: "event"
  event_aggregate(
    # distinct select on columns
    distinct_on: [event_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_order_by!]

    # filter the rows returned
    where: event_bool_exp
  ): event_aggregate!

  # fetch data from the table: "event" using primary key columns
  event_by_pk(id: Int!): event

  # fetch data from the table: "requirement"
  requirement(
    # distinct select on columns
    distinct_on: [requirement_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [requirement_order_by!]

    # filter the rows returned
    where: requirement_bool_exp
  ): [requirement!]!

  # fetch aggregated fields from the table: "requirement"
  requirement_aggregate(
    # distinct select on columns
    distinct_on: [requirement_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [requirement_order_by!]

    # filter the rows returned
    where: requirement_bool_exp
  ): requirement_aggregate!

  # fetch data from the table: "requirement" using primary key columns
  requirement_by_pk(id: Int!): requirement

  # fetch data from the table: "sailebot"
  sailebot(
    # distinct select on columns
    distinct_on: [sailebot_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sailebot_order_by!]

    # filter the rows returned
    where: sailebot_bool_exp
  ): [sailebot!]!

  # fetch aggregated fields from the table: "sailebot"
  sailebot_aggregate(
    # distinct select on columns
    distinct_on: [sailebot_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sailebot_order_by!]

    # filter the rows returned
    where: sailebot_bool_exp
  ): sailebot_aggregate!

  # fetch data from the table: "sailebot" using primary key columns
  sailebot_by_pk(id: Int!): sailebot

  # fetch data from the table: "schedule"
  schedule(
    # distinct select on columns
    distinct_on: [schedule_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [schedule_order_by!]

    # filter the rows returned
    where: schedule_bool_exp
  ): [schedule!]!

  # fetch aggregated fields from the table: "schedule"
  schedule_aggregate(
    # distinct select on columns
    distinct_on: [schedule_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [schedule_order_by!]

    # filter the rows returned
    where: schedule_bool_exp
  ): schedule_aggregate!

  # fetch data from the table: "schedule" using primary key columns
  schedule_by_pk(id: Int!): schedule

  # fetch data from the table: "target"
  target(
    # distinct select on columns
    distinct_on: [target_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [target_order_by!]

    # filter the rows returned
    where: target_bool_exp
  ): [target!]!

  # fetch aggregated fields from the table: "target"
  target_aggregate(
    # distinct select on columns
    distinct_on: [target_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [target_order_by!]

    # filter the rows returned
    where: target_bool_exp
  ): target_aggregate!

  # fetch data from the table: "target" using primary key columns
  target_by_pk(id: Int!): target

  # fetch data from the table: "template"
  template(
    # distinct select on columns
    distinct_on: [template_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [template_order_by!]

    # filter the rows returned
    where: template_bool_exp
  ): [template!]!

  # fetch aggregated fields from the table: "template"
  template_aggregate(
    # distinct select on columns
    distinct_on: [template_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [template_order_by!]

    # filter the rows returned
    where: template_bool_exp
  ): template_aggregate!

  # fetch data from the table: "template" using primary key columns
  template_by_pk(id: Int!): template
}

# columns and relationships of "requirement"
type requirement @model{
  # An object relationship
  client: client!
  client_id: Int!
  function: String
  geography: String
  id: Int!
  level: String
  name: String
  size: Int
  source: String
}

# aggregated selection of "requirement"
type requirement_aggregate {
  aggregate: requirement_aggregate_fields
  nodes: [requirement!]!
}

# aggregate fields of "requirement"
type requirement_aggregate_fields {
  avg: requirement_avg_fields
  count(columns: [requirement_select_column!], distinct: Boolean): Int
  max: requirement_max_fields
  min: requirement_min_fields
  stddev: requirement_stddev_fields
  stddev_pop: requirement_stddev_pop_fields
  stddev_samp: requirement_stddev_samp_fields
  sum: requirement_sum_fields
  var_pop: requirement_var_pop_fields
  var_samp: requirement_var_samp_fields
  variance: requirement_variance_fields
}

# order by aggregate values of table "requirement"
input requirement_aggregate_order_by {
  avg: requirement_avg_order_by
  count: order_by
  max: requirement_max_order_by
  min: requirement_min_order_by
  stddev: requirement_stddev_order_by
  stddev_pop: requirement_stddev_pop_order_by
  stddev_samp: requirement_stddev_samp_order_by
  sum: requirement_sum_order_by
  var_pop: requirement_var_pop_order_by
  var_samp: requirement_var_samp_order_by
  variance: requirement_variance_order_by
}

# input type for inserting array relation for remote table "requirement"
input requirement_arr_rel_insert_input {
  data: [requirement_insert_input!]!
  on_conflict: requirement_on_conflict
}

# aggregate avg on columns
type requirement_avg_fields {
  client_id: Float
  id: Float
  size: Float
}

# order by avg() on columns of table "requirement"
input requirement_avg_order_by {
  client_id: order_by
  id: order_by
  size: order_by
}

# Boolean expression to filter rows from the table "requirement". All fields are combined with a logical 'AND'.
input requirement_bool_exp {
  _and: [requirement_bool_exp]
  _not: requirement_bool_exp
  _or: [requirement_bool_exp]
  client: client_bool_exp
  client_id: Int_comparison_exp
  function: String_comparison_exp
  geography: String_comparison_exp
  id: Int_comparison_exp
  level: String_comparison_exp
  name: String_comparison_exp
  size: Int_comparison_exp
  source: String_comparison_exp
}

# unique or primary key constraints on table "requirement"
enum requirement_constraint {
  # unique or primary key constraint
  requirement_pkey
}

# input type for incrementing integer columne in table "requirement"
input requirement_inc_input {
  client_id: Int
  id: Int
  size: Int
}

# input type for inserting data into table "requirement"
input requirement_insert_input {
  client: client_obj_rel_insert_input
  client_id: Int
  function: String
  geography: String
  id: Int
  level: String
  name: String
  size: Int
  source: String
}

# aggregate max on columns
type requirement_max_fields {
  client_id: Int
  function: String
  geography: String
  id: Int
  level: String
  name: String
  size: Int
  source: String
}

# order by max() on columns of table "requirement"
input requirement_max_order_by {
  client_id: order_by
  function: order_by
  geography: order_by
  id: order_by
  level: order_by
  name: order_by
  size: order_by
  source: order_by
}

# aggregate min on columns
type requirement_min_fields {
  client_id: Int
  function: String
  geography: String
  id: Int
  level: String
  name: String
  size: Int
  source: String
}

# order by min() on columns of table "requirement"
input requirement_min_order_by {
  client_id: order_by
  function: order_by
  geography: order_by
  id: order_by
  level: order_by
  name: order_by
  size: order_by
  source: order_by
}

# response of any mutation on the table "requirement"
type requirement_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [requirement!]!
}

# input type for inserting object relation for remote table "requirement"
input requirement_obj_rel_insert_input {
  data: requirement_insert_input!
  on_conflict: requirement_on_conflict
}

# on conflict condition type for table "requirement"
input requirement_on_conflict {
  constraint: requirement_constraint!
  update_columns: [requirement_update_column!]!
  where: requirement_bool_exp
}

# ordering options when selecting data from "requirement"
input requirement_order_by {
  client: client_order_by
  client_id: order_by
  function: order_by
  geography: order_by
  id: order_by
  level: order_by
  name: order_by
  size: order_by
  source: order_by
}

# select columns of table "requirement"
enum requirement_select_column {
  # column name
  client_id

  # column name
  function

  # column name
  geography

  # column name
  id

  # column name
  level

  # column name
  name

  # column name
  size

  # column name
  source
}

# input type for updating data in table "requirement"
input requirement_set_input {
  client_id: Int
  function: String
  geography: String
  id: Int
  level: String
  name: String
  size: Int
  source: String
}

# aggregate stddev on columns
type requirement_stddev_fields {
  client_id: Float
  id: Float
  size: Float
}

# order by stddev() on columns of table "requirement"
input requirement_stddev_order_by {
  client_id: order_by
  id: order_by
  size: order_by
}

# aggregate stddev_pop on columns
type requirement_stddev_pop_fields {
  client_id: Float
  id: Float
  size: Float
}

# order by stddev_pop() on columns of table "requirement"
input requirement_stddev_pop_order_by {
  client_id: order_by
  id: order_by
  size: order_by
}

# aggregate stddev_samp on columns
type requirement_stddev_samp_fields {
  client_id: Float
  id: Float
  size: Float
}

# order by stddev_samp() on columns of table "requirement"
input requirement_stddev_samp_order_by {
  client_id: order_by
  id: order_by
  size: order_by
}

# aggregate sum on columns
type requirement_sum_fields {
  client_id: Int
  id: Int
  size: Int
}

# order by sum() on columns of table "requirement"
input requirement_sum_order_by {
  client_id: order_by
  id: order_by
  size: order_by
}

# update columns of table "requirement"
enum requirement_update_column {
  # column name
  client_id

  # column name
  function

  # column name
  geography

  # column name
  id

  # column name
  level

  # column name
  name

  # column name
  size

  # column name
  source
}

# aggregate var_pop on columns
type requirement_var_pop_fields {
  client_id: Float
  id: Float
  size: Float
}

# order by var_pop() on columns of table "requirement"
input requirement_var_pop_order_by {
  client_id: order_by
  id: order_by
  size: order_by
}

# aggregate var_samp on columns
type requirement_var_samp_fields {
  client_id: Float
  id: Float
  size: Float
}

# order by var_samp() on columns of table "requirement"
input requirement_var_samp_order_by {
  client_id: order_by
  id: order_by
  size: order_by
}

# aggregate variance on columns
type requirement_variance_fields {
  client_id: Float
  id: Float
  size: Float
}

# order by variance() on columns of table "requirement"
input requirement_variance_order_by {
  client_id: order_by
  id: order_by
  size: order_by
}

# columns and relationships of "sailebot"
type sailebot @model{
  # An array relationship
  accounts(
    # distinct select on columns
    distinct_on: [account_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_order_by!]

    # filter the rows returned
    where: account_bool_exp
  ): [account!]!

  # An aggregated array relationship
  accounts_aggregate(
    # distinct select on columns
    distinct_on: [account_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_order_by!]

    # filter the rows returned
    where: account_bool_exp
  ): account_aggregate!

  # An array relationship
  campaigns(
    # distinct select on columns
    distinct_on: [campaign_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [campaign_order_by!]

    # filter the rows returned
    where: campaign_bool_exp
  ): [campaign!]!

  # An aggregated array relationship
  campaigns_aggregate(
    # distinct select on columns
    distinct_on: [campaign_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [campaign_order_by!]

    # filter the rows returned
    where: campaign_bool_exp
  ): campaign_aggregate!

  # An object relationship
  client: client!
  client_id: Int!

  # An array relationship
  domains(
    # distinct select on columns
    distinct_on: [domains_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [domains_order_by!]

    # filter the rows returned
    where: domains_bool_exp
  ): [domains!]!

  # An aggregated array relationship
  domains_aggregate(
    # distinct select on columns
    distinct_on: [domains_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [domains_order_by!]

    # filter the rows returned
    where: domains_bool_exp
  ): domains_aggregate!
  id: Int!
  name: String
  no_targets: Int
}

# aggregated selection of "sailebot"
type sailebot_aggregate {
  aggregate: sailebot_aggregate_fields
  nodes: [sailebot!]!
}

# aggregate fields of "sailebot"
type sailebot_aggregate_fields {
  avg: sailebot_avg_fields
  count(columns: [sailebot_select_column!], distinct: Boolean): Int
  max: sailebot_max_fields
  min: sailebot_min_fields
  stddev: sailebot_stddev_fields
  stddev_pop: sailebot_stddev_pop_fields
  stddev_samp: sailebot_stddev_samp_fields
  sum: sailebot_sum_fields
  var_pop: sailebot_var_pop_fields
  var_samp: sailebot_var_samp_fields
  variance: sailebot_variance_fields
}

# order by aggregate values of table "sailebot"
input sailebot_aggregate_order_by {
  avg: sailebot_avg_order_by
  count: order_by
  max: sailebot_max_order_by
  min: sailebot_min_order_by
  stddev: sailebot_stddev_order_by
  stddev_pop: sailebot_stddev_pop_order_by
  stddev_samp: sailebot_stddev_samp_order_by
  sum: sailebot_sum_order_by
  var_pop: sailebot_var_pop_order_by
  var_samp: sailebot_var_samp_order_by
  variance: sailebot_variance_order_by
}

# input type for inserting array relation for remote table "sailebot"
input sailebot_arr_rel_insert_input {
  data: [sailebot_insert_input!]!
  on_conflict: sailebot_on_conflict
}

# aggregate avg on columns
type sailebot_avg_fields {
  client_id: Float
  id: Float
  no_targets: Float
}

# order by avg() on columns of table "sailebot"
input sailebot_avg_order_by {
  client_id: order_by
  id: order_by
  no_targets: order_by
}

# Boolean expression to filter rows from the table "sailebot". All fields are combined with a logical 'AND'.
input sailebot_bool_exp {
  _and: [sailebot_bool_exp]
  _not: sailebot_bool_exp
  _or: [sailebot_bool_exp]
  accounts: account_bool_exp
  campaigns: campaign_bool_exp
  client: client_bool_exp
  client_id: Int_comparison_exp
  domains: domains_bool_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  no_targets: Int_comparison_exp
}

# unique or primary key constraints on table "sailebot"
enum sailebot_constraint {
  # unique or primary key constraint
  sailebot_id_key

  # unique or primary key constraint
  sailebot_pkey
}

# input type for incrementing integer columne in table "sailebot"
input sailebot_inc_input {
  client_id: Int
  id: Int
  no_targets: Int
}

# input type for inserting data into table "sailebot"
input sailebot_insert_input {
  accounts: account_arr_rel_insert_input
  campaigns: campaign_arr_rel_insert_input
  client: client_obj_rel_insert_input
  client_id: Int
  domains: domains_arr_rel_insert_input
  id: Int
  name: String
  no_targets: Int
}

# aggregate max on columns
type sailebot_max_fields {
  client_id: Int
  id: Int
  name: String
  no_targets: Int
}

# order by max() on columns of table "sailebot"
input sailebot_max_order_by {
  client_id: order_by
  id: order_by
  name: order_by
  no_targets: order_by
}

# aggregate min on columns
type sailebot_min_fields {
  client_id: Int
  id: Int
  name: String
  no_targets: Int
}

# order by min() on columns of table "sailebot"
input sailebot_min_order_by {
  client_id: order_by
  id: order_by
  name: order_by
  no_targets: order_by
}

# response of any mutation on the table "sailebot"
type sailebot_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [sailebot!]!
}

# input type for inserting object relation for remote table "sailebot"
input sailebot_obj_rel_insert_input {
  data: sailebot_insert_input!
  on_conflict: sailebot_on_conflict
}

# on conflict condition type for table "sailebot"
input sailebot_on_conflict {
  constraint: sailebot_constraint!
  update_columns: [sailebot_update_column!]!
  where: sailebot_bool_exp
}

# ordering options when selecting data from "sailebot"
input sailebot_order_by {
  accounts_aggregate: account_aggregate_order_by
  campaigns_aggregate: campaign_aggregate_order_by
  client: client_order_by
  client_id: order_by
  domains_aggregate: domains_aggregate_order_by
  id: order_by
  name: order_by
  no_targets: order_by
}

# select columns of table "sailebot"
enum sailebot_select_column {
  # column name
  client_id

  # column name
  id

  # column name
  name

  # column name
  no_targets
}

# input type for updating data in table "sailebot"
input sailebot_set_input {
  client_id: Int
  id: Int
  name: String
  no_targets: Int
}

# aggregate stddev on columns
type sailebot_stddev_fields {
  client_id: Float
  id: Float
  no_targets: Float
}

# order by stddev() on columns of table "sailebot"
input sailebot_stddev_order_by {
  client_id: order_by
  id: order_by
  no_targets: order_by
}

# aggregate stddev_pop on columns
type sailebot_stddev_pop_fields {
  client_id: Float
  id: Float
  no_targets: Float
}

# order by stddev_pop() on columns of table "sailebot"
input sailebot_stddev_pop_order_by {
  client_id: order_by
  id: order_by
  no_targets: order_by
}

# aggregate stddev_samp on columns
type sailebot_stddev_samp_fields {
  client_id: Float
  id: Float
  no_targets: Float
}

# order by stddev_samp() on columns of table "sailebot"
input sailebot_stddev_samp_order_by {
  client_id: order_by
  id: order_by
  no_targets: order_by
}

# aggregate sum on columns
type sailebot_sum_fields {
  client_id: Int
  id: Int
  no_targets: Int
}

# order by sum() on columns of table "sailebot"
input sailebot_sum_order_by {
  client_id: order_by
  id: order_by
  no_targets: order_by
}

# update columns of table "sailebot"
enum sailebot_update_column {
  # column name
  client_id

  # column name
  id

  # column name
  name

  # column name
  no_targets
}

# aggregate var_pop on columns
type sailebot_var_pop_fields {
  client_id: Float
  id: Float
  no_targets: Float
}

# order by var_pop() on columns of table "sailebot"
input sailebot_var_pop_order_by {
  client_id: order_by
  id: order_by
  no_targets: order_by
}

# aggregate var_samp on columns
type sailebot_var_samp_fields {
  client_id: Float
  id: Float
  no_targets: Float
}

# order by var_samp() on columns of table "sailebot"
input sailebot_var_samp_order_by {
  client_id: order_by
  id: order_by
  no_targets: order_by
}

# aggregate variance on columns
type sailebot_variance_fields {
  client_id: Float
  id: Float
  no_targets: Float
}

# order by variance() on columns of table "sailebot"
input sailebot_variance_order_by {
  client_id: order_by
  id: order_by
  no_targets: order_by
}

# columns and relationships of "schedule"
type schedule @model{
  campaign_id: Int!
  daily_outbound_account_limit: Int
  id: Int!
  no_targets: Int
}

# aggregated selection of "schedule"
type schedule_aggregate {
  aggregate: schedule_aggregate_fields
  nodes: [schedule!]!
}

# aggregate fields of "schedule"
type schedule_aggregate_fields {
  avg: schedule_avg_fields
  count(columns: [schedule_select_column!], distinct: Boolean): Int
  max: schedule_max_fields
  min: schedule_min_fields
  stddev: schedule_stddev_fields
  stddev_pop: schedule_stddev_pop_fields
  stddev_samp: schedule_stddev_samp_fields
  sum: schedule_sum_fields
  var_pop: schedule_var_pop_fields
  var_samp: schedule_var_samp_fields
  variance: schedule_variance_fields
}

# order by aggregate values of table "schedule"
input schedule_aggregate_order_by {
  avg: schedule_avg_order_by
  count: order_by
  max: schedule_max_order_by
  min: schedule_min_order_by
  stddev: schedule_stddev_order_by
  stddev_pop: schedule_stddev_pop_order_by
  stddev_samp: schedule_stddev_samp_order_by
  sum: schedule_sum_order_by
  var_pop: schedule_var_pop_order_by
  var_samp: schedule_var_samp_order_by
  variance: schedule_variance_order_by
}

# input type for inserting array relation for remote table "schedule"
input schedule_arr_rel_insert_input {
  data: [schedule_insert_input!]!
  on_conflict: schedule_on_conflict
}

# aggregate avg on columns
type schedule_avg_fields {
  campaign_id: Float
  daily_outbound_account_limit: Float
  id: Float
  no_targets: Float
}

# order by avg() on columns of table "schedule"
input schedule_avg_order_by {
  campaign_id: order_by
  daily_outbound_account_limit: order_by
  id: order_by
  no_targets: order_by
}

# Boolean expression to filter rows from the table "schedule". All fields are combined with a logical 'AND'.
input schedule_bool_exp {
  _and: [schedule_bool_exp]
  _not: schedule_bool_exp
  _or: [schedule_bool_exp]
  campaign_id: Int_comparison_exp
  daily_outbound_account_limit: Int_comparison_exp
  id: Int_comparison_exp
  no_targets: Int_comparison_exp
}

# unique or primary key constraints on table "schedule"
enum schedule_constraint {
  # unique or primary key constraint
  schedule_pkey
}

# input type for incrementing integer columne in table "schedule"
input schedule_inc_input {
  campaign_id: Int
  daily_outbound_account_limit: Int
  id: Int
  no_targets: Int
}

# input type for inserting data into table "schedule"
input schedule_insert_input {
  campaign_id: Int
  daily_outbound_account_limit: Int
  id: Int
  no_targets: Int
}

# aggregate max on columns
type schedule_max_fields {
  campaign_id: Int
  daily_outbound_account_limit: Int
  id: Int
  no_targets: Int
}

# order by max() on columns of table "schedule"
input schedule_max_order_by {
  campaign_id: order_by
  daily_outbound_account_limit: order_by
  id: order_by
  no_targets: order_by
}

# aggregate min on columns
type schedule_min_fields {
  campaign_id: Int
  daily_outbound_account_limit: Int
  id: Int
  no_targets: Int
}

# order by min() on columns of table "schedule"
input schedule_min_order_by {
  campaign_id: order_by
  daily_outbound_account_limit: order_by
  id: order_by
  no_targets: order_by
}

# response of any mutation on the table "schedule"
type schedule_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [schedule!]!
}

# input type for inserting object relation for remote table "schedule"
input schedule_obj_rel_insert_input {
  data: schedule_insert_input!
  on_conflict: schedule_on_conflict
}

# on conflict condition type for table "schedule"
input schedule_on_conflict {
  constraint: schedule_constraint!
  update_columns: [schedule_update_column!]!
  where: schedule_bool_exp
}

# ordering options when selecting data from "schedule"
input schedule_order_by {
  campaign_id: order_by
  daily_outbound_account_limit: order_by
  id: order_by
  no_targets: order_by
}

# select columns of table "schedule"
enum schedule_select_column {
  # column name
  campaign_id

  # column name
  daily_outbound_account_limit

  # column name
  id

  # column name
  no_targets
}

# input type for updating data in table "schedule"
input schedule_set_input {
  campaign_id: Int
  daily_outbound_account_limit: Int
  id: Int
  no_targets: Int
}

# aggregate stddev on columns
type schedule_stddev_fields {
  campaign_id: Float
  daily_outbound_account_limit: Float
  id: Float
  no_targets: Float
}

# order by stddev() on columns of table "schedule"
input schedule_stddev_order_by {
  campaign_id: order_by
  daily_outbound_account_limit: order_by
  id: order_by
  no_targets: order_by
}

# aggregate stddev_pop on columns
type schedule_stddev_pop_fields {
  campaign_id: Float
  daily_outbound_account_limit: Float
  id: Float
  no_targets: Float
}

# order by stddev_pop() on columns of table "schedule"
input schedule_stddev_pop_order_by {
  campaign_id: order_by
  daily_outbound_account_limit: order_by
  id: order_by
  no_targets: order_by
}

# aggregate stddev_samp on columns
type schedule_stddev_samp_fields {
  campaign_id: Float
  daily_outbound_account_limit: Float
  id: Float
  no_targets: Float
}

# order by stddev_samp() on columns of table "schedule"
input schedule_stddev_samp_order_by {
  campaign_id: order_by
  daily_outbound_account_limit: order_by
  id: order_by
  no_targets: order_by
}

# aggregate sum on columns
type schedule_sum_fields {
  campaign_id: Int
  daily_outbound_account_limit: Int
  id: Int
  no_targets: Int
}

# order by sum() on columns of table "schedule"
input schedule_sum_order_by {
  campaign_id: order_by
  daily_outbound_account_limit: order_by
  id: order_by
  no_targets: order_by
}

# update columns of table "schedule"
enum schedule_update_column {
  # column name
  campaign_id

  # column name
  daily_outbound_account_limit

  # column name
  id

  # column name
  no_targets
}

# aggregate var_pop on columns
type schedule_var_pop_fields {
  campaign_id: Float
  daily_outbound_account_limit: Float
  id: Float
  no_targets: Float
}

# order by var_pop() on columns of table "schedule"
input schedule_var_pop_order_by {
  campaign_id: order_by
  daily_outbound_account_limit: order_by
  id: order_by
  no_targets: order_by
}

# aggregate var_samp on columns
type schedule_var_samp_fields {
  campaign_id: Float
  daily_outbound_account_limit: Float
  id: Float
  no_targets: Float
}

# order by var_samp() on columns of table "schedule"
input schedule_var_samp_order_by {
  campaign_id: order_by
  daily_outbound_account_limit: order_by
  id: order_by
  no_targets: order_by
}

# aggregate variance on columns
type schedule_variance_fields {
  campaign_id: Float
  daily_outbound_account_limit: Float
  id: Float
  no_targets: Float
}

# order by variance() on columns of table "schedule"
input schedule_variance_order_by {
  campaign_id: order_by
  daily_outbound_account_limit: order_by
  id: order_by
  no_targets: order_by
}

# expression to compare columns of type String. All fields are combined with logical 'AND'.
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

# subscription root
type subscription_root {
  # fetch data from the table: "account"
  account(
    # distinct select on columns
    distinct_on: [account_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_order_by!]

    # filter the rows returned
    where: account_bool_exp
  ): [account!]!

  # fetch aggregated fields from the table: "account"
  account_aggregate(
    # distinct select on columns
    distinct_on: [account_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [account_order_by!]

    # filter the rows returned
    where: account_bool_exp
  ): account_aggregate!

  # fetch data from the table: "account" using primary key columns
  account_by_pk(id: Int!): account

  # fetch data from the table: "campaign"
  campaign(
    # distinct select on columns
    distinct_on: [campaign_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [campaign_order_by!]

    # filter the rows returned
    where: campaign_bool_exp
  ): [campaign!]!

  # fetch aggregated fields from the table: "campaign"
  campaign_aggregate(
    # distinct select on columns
    distinct_on: [campaign_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [campaign_order_by!]

    # filter the rows returned
    where: campaign_bool_exp
  ): campaign_aggregate!

  # fetch data from the table: "campaign" using primary key columns
  campaign_by_pk(id: Int!): campaign

  # fetch data from the table: "client"
  client(
    # distinct select on columns
    distinct_on: [client_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [client_order_by!]

    # filter the rows returned
    where: client_bool_exp
  ): [client!]!

  # fetch aggregated fields from the table: "client"
  client_aggregate(
    # distinct select on columns
    distinct_on: [client_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [client_order_by!]

    # filter the rows returned
    where: client_bool_exp
  ): client_aggregate!

  # fetch data from the table: "client" using primary key columns
  client_by_pk(id: Int!): client

  # fetch data from the table: "company"
  company(
    # distinct select on columns
    distinct_on: [company_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [company_order_by!]

    # filter the rows returned
    where: company_bool_exp
  ): [company!]!

  # fetch aggregated fields from the table: "company"
  company_aggregate(
    # distinct select on columns
    distinct_on: [company_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [company_order_by!]

    # filter the rows returned
    where: company_bool_exp
  ): company_aggregate!

  # fetch data from the table: "company" using primary key columns
  company_by_pk(id: Int!): company

  # fetch data from the table: "domains"
  domains(
    # distinct select on columns
    distinct_on: [domains_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [domains_order_by!]

    # filter the rows returned
    where: domains_bool_exp
  ): [domains!]!

  # fetch aggregated fields from the table: "domains"
  domains_aggregate(
    # distinct select on columns
    distinct_on: [domains_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [domains_order_by!]

    # filter the rows returned
    where: domains_bool_exp
  ): domains_aggregate!

  # fetch data from the table: "domains" using primary key columns
  domains_by_pk(id: Int!): domains

  # fetch data from the table: "event"
  event(
    # distinct select on columns
    distinct_on: [event_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_order_by!]

    # filter the rows returned
    where: event_bool_exp
  ): [event!]!

  # fetch aggregated fields from the table: "event"
  event_aggregate(
    # distinct select on columns
    distinct_on: [event_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_order_by!]

    # filter the rows returned
    where: event_bool_exp
  ): event_aggregate!

  # fetch data from the table: "event" using primary key columns
  event_by_pk(id: Int!): event

  # fetch data from the table: "requirement"
  requirement(
    # distinct select on columns
    distinct_on: [requirement_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [requirement_order_by!]

    # filter the rows returned
    where: requirement_bool_exp
  ): [requirement!]!

  # fetch aggregated fields from the table: "requirement"
  requirement_aggregate(
    # distinct select on columns
    distinct_on: [requirement_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [requirement_order_by!]

    # filter the rows returned
    where: requirement_bool_exp
  ): requirement_aggregate!

  # fetch data from the table: "requirement" using primary key columns
  requirement_by_pk(id: Int!): requirement

  # fetch data from the table: "sailebot"
  sailebot(
    # distinct select on columns
    distinct_on: [sailebot_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sailebot_order_by!]

    # filter the rows returned
    where: sailebot_bool_exp
  ): [sailebot!]!

  # fetch aggregated fields from the table: "sailebot"
  sailebot_aggregate(
    # distinct select on columns
    distinct_on: [sailebot_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [sailebot_order_by!]

    # filter the rows returned
    where: sailebot_bool_exp
  ): sailebot_aggregate!

  # fetch data from the table: "sailebot" using primary key columns
  sailebot_by_pk(id: Int!): sailebot

  # fetch data from the table: "schedule"
  schedule(
    # distinct select on columns
    distinct_on: [schedule_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [schedule_order_by!]

    # filter the rows returned
    where: schedule_bool_exp
  ): [schedule!]!

  # fetch aggregated fields from the table: "schedule"
  schedule_aggregate(
    # distinct select on columns
    distinct_on: [schedule_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [schedule_order_by!]

    # filter the rows returned
    where: schedule_bool_exp
  ): schedule_aggregate!

  # fetch data from the table: "schedule" using primary key columns
  schedule_by_pk(id: Int!): schedule

  # fetch data from the table: "target"
  target(
    # distinct select on columns
    distinct_on: [target_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [target_order_by!]

    # filter the rows returned
    where: target_bool_exp
  ): [target!]!

  # fetch aggregated fields from the table: "target"
  target_aggregate(
    # distinct select on columns
    distinct_on: [target_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [target_order_by!]

    # filter the rows returned
    where: target_bool_exp
  ): target_aggregate!

  # fetch data from the table: "target" using primary key columns
  target_by_pk(id: Int!): target

  # fetch data from the table: "template"
  template(
    # distinct select on columns
    distinct_on: [template_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [template_order_by!]

    # filter the rows returned
    where: template_bool_exp
  ): [template!]!

  # fetch aggregated fields from the table: "template"
  template_aggregate(
    # distinct select on columns
    distinct_on: [template_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [template_order_by!]

    # filter the rows returned
    where: template_bool_exp
  ): template_aggregate!

  # fetch data from the table: "template" using primary key columns
  template_by_pk(id: Int!): template
}

# columns and relationships of "target"
type target @model{
  # An object relationship
  account: account!
  account_id: Int!
  bounce_type: String

  # An object relationship
  campaign: campaign
  campaign_id: Int
  email: String!

  # An array relationship
  events(
    # distinct select on columns
    distinct_on: [event_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_order_by!]

    # filter the rows returned
    where: event_bool_exp
  ): [event!]!

  # An aggregated array relationship
  events_aggregate(
    # distinct select on columns
    distinct_on: [event_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [event_order_by!]

    # filter the rows returned
    where: event_bool_exp
  ): event_aggregate!
  fax: String
  first_outbound_done: Boolean
  firstname: String
  gender: String
  id: Int!
  is_ema_eligible: Boolean
  is_eva_eligible: Boolean
  is_referral: Boolean
  lastname: String
  member_status: String
  phone: String
  position: String
  role: String
  sam_status: String
  second_outbound_done: Boolean
  source: String
  title: String
  to_followup: Boolean
}

# aggregated selection of "target"
type target_aggregate {
  aggregate: target_aggregate_fields
  nodes: [target!]!
}

# aggregate fields of "target"
type target_aggregate_fields {
  avg: target_avg_fields
  count(columns: [target_select_column!], distinct: Boolean): Int
  max: target_max_fields
  min: target_min_fields
  stddev: target_stddev_fields
  stddev_pop: target_stddev_pop_fields
  stddev_samp: target_stddev_samp_fields
  sum: target_sum_fields
  var_pop: target_var_pop_fields
  var_samp: target_var_samp_fields
  variance: target_variance_fields
}

# order by aggregate values of table "target"
input target_aggregate_order_by {
  avg: target_avg_order_by
  count: order_by
  max: target_max_order_by
  min: target_min_order_by
  stddev: target_stddev_order_by
  stddev_pop: target_stddev_pop_order_by
  stddev_samp: target_stddev_samp_order_by
  sum: target_sum_order_by
  var_pop: target_var_pop_order_by
  var_samp: target_var_samp_order_by
  variance: target_variance_order_by
}

# input type for inserting array relation for remote table "target"
input target_arr_rel_insert_input {
  data: [target_insert_input!]!
  on_conflict: target_on_conflict
}

# aggregate avg on columns
type target_avg_fields {
  account_id: Float
  campaign_id: Float
  id: Float
}

# order by avg() on columns of table "target"
input target_avg_order_by {
  account_id: order_by
  campaign_id: order_by
  id: order_by
}

# Boolean expression to filter rows from the table "target". All fields are combined with a logical 'AND'.
input target_bool_exp {
  _and: [target_bool_exp]
  _not: target_bool_exp
  _or: [target_bool_exp]
  account: account_bool_exp
  account_id: Int_comparison_exp
  bounce_type: String_comparison_exp
  campaign: campaign_bool_exp
  campaign_id: Int_comparison_exp
  email: String_comparison_exp
  events: event_bool_exp
  fax: String_comparison_exp
  first_outbound_done: Boolean_comparison_exp
  firstname: String_comparison_exp
  gender: String_comparison_exp
  id: Int_comparison_exp
  is_ema_eligible: Boolean_comparison_exp
  is_eva_eligible: Boolean_comparison_exp
  is_referral: Boolean_comparison_exp
  lastname: String_comparison_exp
  member_status: String_comparison_exp
  phone: String_comparison_exp
  position: String_comparison_exp
  role: String_comparison_exp
  sam_status: String_comparison_exp
  second_outbound_done: Boolean_comparison_exp
  source: String_comparison_exp
  title: String_comparison_exp
  to_followup: Boolean_comparison_exp
}

# unique or primary key constraints on table "target"
enum target_constraint {
  # unique or primary key constraint
  target_pkey
}

# input type for incrementing integer columne in table "target"
input target_inc_input {
  account_id: Int
  campaign_id: Int
  id: Int
}

# input type for inserting data into table "target"
input target_insert_input {
  account: account_obj_rel_insert_input
  account_id: Int
  bounce_type: String
  campaign: campaign_obj_rel_insert_input
  campaign_id: Int
  email: String
  events: event_arr_rel_insert_input
  fax: String
  first_outbound_done: Boolean
  firstname: String
  gender: String
  id: Int
  is_ema_eligible: Boolean
  is_eva_eligible: Boolean
  is_referral: Boolean
  lastname: String
  member_status: String
  phone: String
  position: String
  role: String
  sam_status: String
  second_outbound_done: Boolean
  source: String
  title: String
  to_followup: Boolean
}

# aggregate max on columns
type target_max_fields {
  account_id: Int
  bounce_type: String
  campaign_id: Int
  email: String
  fax: String
  firstname: String
  gender: String
  id: Int
  lastname: String
  member_status: String
  phone: String
  position: String
  role: String
  sam_status: String
  source: String
  title: String
}

# order by max() on columns of table "target"
input target_max_order_by {
  account_id: order_by
  bounce_type: order_by
  campaign_id: order_by
  email: order_by
  fax: order_by
  firstname: order_by
  gender: order_by
  id: order_by
  lastname: order_by
  member_status: order_by
  phone: order_by
  position: order_by
  role: order_by
  sam_status: order_by
  source: order_by
  title: order_by
}

# aggregate min on columns
type target_min_fields {
  account_id: Int
  bounce_type: String
  campaign_id: Int
  email: String
  fax: String
  firstname: String
  gender: String
  id: Int
  lastname: String
  member_status: String
  phone: String
  position: String
  role: String
  sam_status: String
  source: String
  title: String
}

# order by min() on columns of table "target"
input target_min_order_by {
  account_id: order_by
  bounce_type: order_by
  campaign_id: order_by
  email: order_by
  fax: order_by
  firstname: order_by
  gender: order_by
  id: order_by
  lastname: order_by
  member_status: order_by
  phone: order_by
  position: order_by
  role: order_by
  sam_status: order_by
  source: order_by
  title: order_by
}

# response of any mutation on the table "target"
type target_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [target!]!
}

# input type for inserting object relation for remote table "target"
input target_obj_rel_insert_input {
  data: target_insert_input!
  on_conflict: target_on_conflict
}

# on conflict condition type for table "target"
input target_on_conflict {
  constraint: target_constraint!
  update_columns: [target_update_column!]!
  where: target_bool_exp
}

# ordering options when selecting data from "target"
input target_order_by {
  account: account_order_by
  account_id: order_by
  bounce_type: order_by
  campaign: campaign_order_by
  campaign_id: order_by
  email: order_by
  events_aggregate: event_aggregate_order_by
  fax: order_by
  first_outbound_done: order_by
  firstname: order_by
  gender: order_by
  id: order_by
  is_ema_eligible: order_by
  is_eva_eligible: order_by
  is_referral: order_by
  lastname: order_by
  member_status: order_by
  phone: order_by
  position: order_by
  role: order_by
  sam_status: order_by
  second_outbound_done: order_by
  source: order_by
  title: order_by
  to_followup: order_by
}

# select columns of table "target"
enum target_select_column {
  # column name
  account_id

  # column name
  bounce_type

  # column name
  campaign_id

  # column name
  email

  # column name
  fax

  # column name
  first_outbound_done

  # column name
  firstname

  # column name
  gender

  # column name
  id

  # column name
  is_ema_eligible

  # column name
  is_eva_eligible

  # column name
  is_referral

  # column name
  lastname

  # column name
  member_status

  # column name
  phone

  # column name
  position

  # column name
  role

  # column name
  sam_status

  # column name
  second_outbound_done

  # column name
  source

  # column name
  title

  # column name
  to_followup
}

# input type for updating data in table "target"
input target_set_input {
  account_id: Int
  bounce_type: String
  campaign_id: Int
  email: String
  fax: String
  first_outbound_done: Boolean
  firstname: String
  gender: String
  id: Int
  is_ema_eligible: Boolean
  is_eva_eligible: Boolean
  is_referral: Boolean
  lastname: String
  member_status: String
  phone: String
  position: String
  role: String
  sam_status: String
  second_outbound_done: Boolean
  source: String
  title: String
  to_followup: Boolean
}

# aggregate stddev on columns
type target_stddev_fields {
  account_id: Float
  campaign_id: Float
  id: Float
}

# order by stddev() on columns of table "target"
input target_stddev_order_by {
  account_id: order_by
  campaign_id: order_by
  id: order_by
}

# aggregate stddev_pop on columns
type target_stddev_pop_fields {
  account_id: Float
  campaign_id: Float
  id: Float
}

# order by stddev_pop() on columns of table "target"
input target_stddev_pop_order_by {
  account_id: order_by
  campaign_id: order_by
  id: order_by
}

# aggregate stddev_samp on columns
type target_stddev_samp_fields {
  account_id: Float
  campaign_id: Float
  id: Float
}

# order by stddev_samp() on columns of table "target"
input target_stddev_samp_order_by {
  account_id: order_by
  campaign_id: order_by
  id: order_by
}

# aggregate sum on columns
type target_sum_fields {
  account_id: Int
  campaign_id: Int
  id: Int
}

# order by sum() on columns of table "target"
input target_sum_order_by {
  account_id: order_by
  campaign_id: order_by
  id: order_by
}

# update columns of table "target"
enum target_update_column {
  # column name
  account_id

  # column name
  bounce_type

  # column name
  campaign_id

  # column name
  email

  # column name
  fax

  # column name
  first_outbound_done

  # column name
  firstname

  # column name
  gender

  # column name
  id

  # column name
  is_ema_eligible

  # column name
  is_eva_eligible

  # column name
  is_referral

  # column name
  lastname

  # column name
  member_status

  # column name
  phone

  # column name
  position

  # column name
  role

  # column name
  sam_status

  # column name
  second_outbound_done

  # column name
  source

  # column name
  title

  # column name
  to_followup
}

# aggregate var_pop on columns
type target_var_pop_fields {
  account_id: Float
  campaign_id: Float
  id: Float
}

# order by var_pop() on columns of table "target"
input target_var_pop_order_by {
  account_id: order_by
  campaign_id: order_by
  id: order_by
}

# aggregate var_samp on columns
type target_var_samp_fields {
  account_id: Float
  campaign_id: Float
  id: Float
}

# order by var_samp() on columns of table "target"
input target_var_samp_order_by {
  account_id: order_by
  campaign_id: order_by
  id: order_by
}

# aggregate variance on columns
type target_variance_fields {
  account_id: Float
  campaign_id: Float
  id: Float
}

# order by variance() on columns of table "target"
input target_variance_order_by {
  account_id: order_by
  campaign_id: order_by
  id: order_by
}

# columns and relationships of "template"
type template @model{
  body_html_text: String
  body_text: String

  # An object relationship
  campaign: campaign!
  campaign_id: Int!
  id: Int!
  name: String
  subject: String
}

# aggregated selection of "template"
type template_aggregate {
  aggregate: template_aggregate_fields
  nodes: [template!]!
}

# aggregate fields of "template"
type template_aggregate_fields {
  avg: template_avg_fields
  count(columns: [template_select_column!], distinct: Boolean): Int
  max: template_max_fields
  min: template_min_fields
  stddev: template_stddev_fields
  stddev_pop: template_stddev_pop_fields
  stddev_samp: template_stddev_samp_fields
  sum: template_sum_fields
  var_pop: template_var_pop_fields
  var_samp: template_var_samp_fields
  variance: template_variance_fields
}

# order by aggregate values of table "template"
input template_aggregate_order_by {
  avg: template_avg_order_by
  count: order_by
  max: template_max_order_by
  min: template_min_order_by
  stddev: template_stddev_order_by
  stddev_pop: template_stddev_pop_order_by
  stddev_samp: template_stddev_samp_order_by
  sum: template_sum_order_by
  var_pop: template_var_pop_order_by
  var_samp: template_var_samp_order_by
  variance: template_variance_order_by
}

# input type for inserting array relation for remote table "template"
input template_arr_rel_insert_input {
  data: [template_insert_input!]!
  on_conflict: template_on_conflict
}

# aggregate avg on columns
type template_avg_fields {
  campaign_id: Float
  id: Float
}

# order by avg() on columns of table "template"
input template_avg_order_by {
  campaign_id: order_by
  id: order_by
}

# Boolean expression to filter rows from the table "template". All fields are combined with a logical 'AND'.
input template_bool_exp {
  _and: [template_bool_exp]
  _not: template_bool_exp
  _or: [template_bool_exp]
  body_html_text: String_comparison_exp
  body_text: String_comparison_exp
  campaign: campaign_bool_exp
  campaign_id: Int_comparison_exp
  id: Int_comparison_exp
  name: String_comparison_exp
  subject: String_comparison_exp
}

# unique or primary key constraints on table "template"
enum template_constraint {
  # unique or primary key constraint
  template_pkey
}

# input type for incrementing integer columne in table "template"
input template_inc_input {
  campaign_id: Int
  id: Int
}

# input type for inserting data into table "template"
input template_insert_input {
  body_html_text: String
  body_text: String
  campaign: campaign_obj_rel_insert_input
  campaign_id: Int
  id: Int
  name: String
  subject: String
}

# aggregate max on columns
type template_max_fields {
  body_html_text: String
  body_text: String
  campaign_id: Int
  id: Int
  name: String
  subject: String
}

# order by max() on columns of table "template"
input template_max_order_by {
  body_html_text: order_by
  body_text: order_by
  campaign_id: order_by
  id: order_by
  name: order_by
  subject: order_by
}

# aggregate min on columns
type template_min_fields {
  body_html_text: String
  body_text: String
  campaign_id: Int
  id: Int
  name: String
  subject: String
}

# order by min() on columns of table "template"
input template_min_order_by {
  body_html_text: order_by
  body_text: order_by
  campaign_id: order_by
  id: order_by
  name: order_by
  subject: order_by
}

# response of any mutation on the table "template"
type template_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [template!]!
}

# input type for inserting object relation for remote table "template"
input template_obj_rel_insert_input {
  data: template_insert_input!
  on_conflict: template_on_conflict
}

# on conflict condition type for table "template"
input template_on_conflict {
  constraint: template_constraint!
  update_columns: [template_update_column!]!
  where: template_bool_exp
}

# ordering options when selecting data from "template"
input template_order_by {
  body_html_text: order_by
  body_text: order_by
  campaign: campaign_order_by
  campaign_id: order_by
  id: order_by
  name: order_by
  subject: order_by
}

# select columns of table "template"
enum template_select_column {
  # column name
  body_html_text

  # column name
  body_text

  # column name
  campaign_id

  # column name
  id

  # column name
  name

  # column name
  subject
}

# input type for updating data in table "template"
input template_set_input {
  body_html_text: String
  body_text: String
  campaign_id: Int
  id: Int
  name: String
  subject: String
}

# aggregate stddev on columns
type template_stddev_fields {
  campaign_id: Float
  id: Float
}

# order by stddev() on columns of table "template"
input template_stddev_order_by {
  campaign_id: order_by
  id: order_by
}

# aggregate stddev_pop on columns
type template_stddev_pop_fields {
  campaign_id: Float
  id: Float
}

# order by stddev_pop() on columns of table "template"
input template_stddev_pop_order_by {
  campaign_id: order_by
  id: order_by
}

# aggregate stddev_samp on columns
type template_stddev_samp_fields {
  campaign_id: Float
  id: Float
}

# order by stddev_samp() on columns of table "template"
input template_stddev_samp_order_by {
  campaign_id: order_by
  id: order_by
}

# aggregate sum on columns
type template_sum_fields {
  campaign_id: Int
  id: Int
}

# order by sum() on columns of table "template"
input template_sum_order_by {
  campaign_id: order_by
  id: order_by
}

# update columns of table "template"
enum template_update_column {
  # column name
  body_html_text

  # column name
  body_text

  # column name
  campaign_id

  # column name
  id

  # column name
  name

  # column name
  subject
}

# aggregate var_pop on columns
type template_var_pop_fields {
  campaign_id: Float
  id: Float
}

# order by var_pop() on columns of table "template"
input template_var_pop_order_by {
  campaign_id: order_by
  id: order_by
}

# aggregate var_samp on columns
type template_var_samp_fields {
  campaign_id: Float
  id: Float
}

# order by var_samp() on columns of table "template"
input template_var_samp_order_by {
  campaign_id: order_by
  id: order_by
}

# aggregate variance on columns
type template_variance_fields {
  campaign_id: Float
  id: Float
}

# order by variance() on columns of table "template"
input template_variance_order_by {
  campaign_id: order_by
  id: order_by
}

